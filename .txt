import React, { useState, useRef, useEffect } from 'react';
import { Upload, Download, Pen, Highlighter, Eraser, ZoomIn, ZoomOut, RotateCcw, Video, Brain, FileText, Image, Save, Undo, Redo, Trash2, Play, Square, Settings, Eye, EyeOff, Camera, Mic, MicOff, History, Zap, MessageSquare } from 'lucide-react';

const API_BASE_URL = 'http://localhost:5000/api';

const PDFEditor = () => {
  const [currentTool, setCurrentTool] = useState('pen');
  const [penColor, setPenColor] = useState('#ff0000');
  const [penSize, setPenSize] = useState(3);
  const [isDrawing, setIsDrawing] = useState(false);
  const [zoom, setZoom] = useState(100);
  const [currentPage, setCurrentPage] = useState(0);
  const [totalPages, setTotalPages] = useState(0);
  const [isRecording, setIsRecording] = useState(false);
  const [recordingTime, setRecordingTime] = useState(0);
  const [fileName, setFileName] = useState('');
  const [showSidebar, setShowSidebar] = useState(true);
  const [activeTab, setActiveTab] = useState('tools');
  const [aiResults, setAiResults] = useState(null);
  const [processingVideo, setProcessingVideo] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);
  const [sessionId, setSessionId] = useState('');
  const [pageImage, setPageImage] = useState(null);
  const [annotations, setAnnotations] = useState([]);
  const [drawingHistory, setDrawingHistory] = useState([]);
  const [historyIndex, setHistoryIndex] = useState(-1);
  const [imageDimensions, setImageDimensions] = useState({ width: 0, height: 0 });
  
  // New state for enhanced features
  const [screenshots, setScreenshots] = useState([]);
  const [recordingWithAudio, setRecordingWithAudio] = useState(false);
  const [originalTranscript, setOriginalTranscript] = useState('');
  const [aiProcessedTranscript, setAiProcessedTranscript] = useState('');
  const [showPreviewModal, setShowPreviewModal] = useState(false);
  const [currentPreview, setCurrentPreview] = useState(null);
  
  const canvasRef = useRef(null);
  const fileInputRef = useRef(null);
  const lastPointRef = useRef(null);
  const imageRef = useRef(new window.Image());

  // Initialize session
  useEffect(() => {
    initializeSession();
  }, []);

  // Canvas setup and drawing logic
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    const rect = canvas.parentElement.getBoundingClientRect();
    
    canvas.width = rect.width;
    canvas.height = rect.height;

    // Clear canvas
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw page image if available
    if (pageImage) {
      const img = imageRef.current;
      img.onload = () => {
        // Calculate dimensions to fit canvas while maintaining aspect ratio
        const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
        const width = img.width * scale;
        const height = img.height * scale;
        const x = (canvas.width - width) / 2;
        const y = (canvas.height - height) / 2;
        
        ctx.drawImage(img, x, y, width, height);
        
        // Store image dimensions for drawing coordinates
        setImageDimensions({ x, y, width, height, scale });
        
        // Redraw annotations
        redrawAnnotations(ctx, x, y, width, height);
      };
      img.onerror = () => {
        console.error('Failed to load image');
      };
      img.src = `data:image/png;base64,${pageImage}`;
    }
  }, [pageImage, zoom, currentPage]);

  // Recording timer effect
  useEffect(() => {
    let interval;
    if (isRecording) {
      interval = setInterval(() => {
        setRecordingTime(prev => prev + 1);
      }, 1000);
    } else {
      setRecordingTime(0);
    }
    return () => clearInterval(interval);
  }, [isRecording]);

  // Load screenshots for current session
  useEffect(() => {
    if (sessionId) {
      loadScreenshots();
    }
  }, [sessionId]);

  const initializeSession = async () => {
    try {
      const response = await fetch(`${API_BASE_URL}/session/create`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
      });
      if (response.ok) {
        const data = await response.json();
        setSessionId(data.session_id);
      } else {
        console.error('Failed to create session');
        setSessionId('local-session-' + Date.now());
      }
    } catch (error) {
      console.error('Error creating session:', error);
      setSessionId('local-session-' + Date.now());
    }
  };

  const loadScreenshots = async () => {
    try {
      const response = await fetch(`${API_BASE_URL}/screenshots/${sessionId}`);
      if (response.ok) {
        const data = await response.json();
        setScreenshots(data.screenshots || []);
      }
    } catch (error) {
      console.error('Error loading screenshots:', error);
    }
  };

  const captureAnnotationScreenshot = async (annotation) => {
    try {
      const response = await fetch(`${API_BASE_URL}/annotations/screenshot`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          session_id: sessionId,
          annotation: annotation,
          page_image: pageImage,
        }),
      });

      if (response.ok) {
        const data = await response.json();
        if (data.screenshot) {
          setScreenshots(prev => [...prev, data.screenshot]);
        }
      }
    } catch (error) {
      console.error('Error capturing screenshot:', error);
    }
  };

  const redrawAnnotations = (ctx, offsetX, offsetY, scaleWidth, scaleHeight) => {
    if (!annotations.length) return;

    annotations.forEach(annotation => {
      if (!annotation.points || !annotation.points.length) return;

      ctx.strokeStyle = annotation.color || '#ff0000';
      ctx.lineWidth = annotation.size || 3;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      
      ctx.beginPath();
      annotation.points.forEach((point, index) => {
        const x = offsetX + (point.x * scaleWidth);
        const y = offsetY + (point.y * scaleHeight);
        if (index === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      ctx.stroke();
    });
  };

  const handleFileUpload = async (event) => {
    const file = event.target.files[0];
    if (!file) return;

    setFileName(file.name);
    setUploadProgress(0);

    const validTypes = ['.pdf', '.png', '.jpg', '.jpeg', '.bmp', '.gif'];
    const fileExtension = '.' + file.name.split('.').pop().toLowerCase();
    if (!validTypes.includes(fileExtension)) {
      alert('Please upload a PDF or image file (PDF, PNG, JPG, JPEG, BMP, GIF)');
      return;
    }

    const formData = new FormData();
    formData.append('file', file);
    formData.append('session_id', sessionId);

    try {
      const progressInterval = setInterval(() => {
        setUploadProgress(prev => {
          if (prev >= 90) {
            clearInterval(progressInterval);
            return 90;
          }
          return prev + 10;
        });
      }, 100);

      const response = await fetch(`${API_BASE_URL}/upload`, {
        method: 'POST',
        body: formData,
      });

      clearInterval(progressInterval);

      if (response.ok) {
        const data = await response.json();
        setUploadProgress(100);
        
        if (data.page_data && data.page_data.image) {
          setPageImage(data.page_data.image);
          setTotalPages(data.total_pages || 1);
          setCurrentPage(0);
          
          setTimeout(() => loadAnnotations(0), 500);
        } else {
          throw new Error('Invalid response data');
        }
      } else {
        const errorData = await response.json().catch(() => ({ error: 'Upload failed' }));
        throw new Error(errorData.error || 'Upload failed');
      }
    } catch (error) {
      console.error('Upload error:', error);
      setUploadProgress(0);
      
      if (file.type.startsWith('image/')) {
        const reader = new FileReader();
        reader.onload = (e) => {
          setPageImage(e.target.result.split(',')[1]);
          setTotalPages(1);
          setCurrentPage(0);
          setUploadProgress(100);
        };
        reader.readAsDataURL(file);
      } else {
        alert(`Upload failed: ${error.message}. Please make sure the backend server is running.`);
      }
    }
  };

  const loadPage = async (pageNum) => {
    if (!sessionId || pageNum < 0) return;

    try {
      const response = await fetch(
        `${API_BASE_URL}/document/page?session_id=${sessionId}&page=${pageNum}`
      );
      
      if (response.ok) {
        const data = await response.json();
        if (data.page_data && data.page_data.image) {
          setPageImage(data.page_data.image);
          setCurrentPage(pageNum);
          setTotalPages(data.total_pages || 1);
          setAnnotations(data.annotations || []);
        }
      } else {
        console.warn('Failed to load page from server');
      }
    } catch (error) {
      console.error('Error loading page:', error);
    }
  };

  const loadAnnotations = async (pageNum) => {
    if (!sessionId) return;

    try {
      const response = await fetch(
        `${API_BASE_URL}/document/page?session_id=${sessionId}&page=${pageNum}`
      );
      
      if (response.ok) {
        const data = await response.json();
        setAnnotations(data.annotations || []);
      }
    } catch (error) {
      console.error('Error loading annotations:', error);
      setAnnotations([]);
    }
  };

  const saveAnnotation = async (annotationData) => {
    if (!sessionId) return;

    try {
      await fetch(`${API_BASE_URL}/annotations/add`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          session_id: sessionId,
          page_number: currentPage,
          annotation: annotationData,
        }),
      });
    } catch (error) {
      console.error('Error saving annotation:', error);
    }
  };

  const clearAnnotations = async () => {
    if (!sessionId) return;

    try {
      await fetch(`${API_BASE_URL}/annotations/clear`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          session_id: sessionId,
          page_number: currentPage,
        }),
      });
      
      // Clear screenshots
      await fetch(`${API_BASE_URL}/screenshots/clear/${sessionId}`, {
        method: 'POST',
      });
      setScreenshots([]);
    } catch (error) {
      console.error('Error clearing annotations:', error);
    }
    
    setAnnotations([]);
    setDrawingHistory([]);
    setHistoryIndex(-1);
    
    // Clear canvas
    const canvas = canvasRef.current;
    if (canvas) {
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      if (pageImage) {
        const img = imageRef.current;
        if (img.complete) {
          const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
          const width = img.width * scale;
          const height = img.height * scale;
          const x = (canvas.width - width) / 2;
          const y = (canvas.height - height) / 2;
          ctx.drawImage(img, x, y, width, height);
        }
      }
    }
  };

  const handleMouseDown = (e) => {
    if (!pageImage) return;

    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();
    
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    const imgX = (x - imageDimensions.x) / imageDimensions.width;
    const imgY = (y - imageDimensions.y) / imageDimensions.height;

    if (imgX < 0 || imgX > 1 || imgY < 0 || imgY > 1) return;

    lastPointRef.current = { x, y };
    setIsDrawing(true);

    const ctx = canvas.getContext('2d');
    ctx.beginPath();
    ctx.moveTo(x, y);
    
    const newAnnotation = {
      type: currentTool,
      color: penColor,
      size: parseInt(penSize),
      points: [{ x: imgX, y: imgY }],
      timestamp: new Date().toISOString(),
    };

    const newAnnotations = [...annotations, newAnnotation];
    setAnnotations(newAnnotations);
    addToHistory(newAnnotations);
  };






  const handleMouseMove = (e) => {
    if (!isDrawing || !pageImage) return;

    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const rect = canvas.getBoundingClientRect();
    
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    const imgX = (x - imageDimensions.x) / imageDimensions.width;
    const imgY = (y - imageDimensions.y) / imageDimensions.height;

    if (imgX < 0 || imgX > 1 || imgY < 0 || imgY > 1) {
      handleMouseUp();
      return;
    }

    if (lastPointRef.current) {
      ctx.strokeStyle = penColor;
      ctx.lineWidth = penSize;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      
      ctx.lineTo(x, y);
      ctx.stroke();

      if (annotations.length > 0) {
        const updatedAnnotations = [...annotations];
        const currentAnnotation = updatedAnnotations[updatedAnnotations.length - 1];
        
        currentAnnotation.points.push({ x: imgX, y: imgY });
        setAnnotations(updatedAnnotations);
      }
    }

    lastPointRef.current = { x, y };
  };

  const handleMouseUp = () => {
    if (!isDrawing) return;

    setIsDrawing(false);
    lastPointRef.current = null;

    if (annotations.length > 0) {
      const currentAnnotation = annotations[annotations.length - 1];
      if (currentAnnotation.points.length > 1) {
        saveAnnotation(currentAnnotation);
        // Capture screenshot for this annotation
        captureAnnotationScreenshot(currentAnnotation);
      }
    }
  };







  
  const addToHistory = (newAnnotations) => {
    const newHistory = drawingHistory.slice(0, historyIndex + 1);
    newHistory.push(newAnnotations);
    setDrawingHistory(newHistory);
    setHistoryIndex(newHistory.length - 1);
  };

  const undo = () => {
    if (historyIndex > 0) {
      const newIndex = historyIndex - 1;
      setHistoryIndex(newIndex);
      setAnnotations(drawingHistory[newIndex]);
      redrawCanvas();
    } else {
      setAnnotations([]);
      setHistoryIndex(-1);
      redrawCanvas();
    }
  };

  const redo = () => {
    if (historyIndex < drawingHistory.length - 1) {
      const newIndex = historyIndex + 1;
      setHistoryIndex(newIndex);
      setAnnotations(drawingHistory[newIndex]);
      redrawCanvas();
    }
  };

  const redrawCanvas = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (pageImage && imageRef.current.complete) {
      const img = imageRef.current;
      const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
      const width = img.width * scale;
      const height = img.height * scale;
      const x = (canvas.width - width) / 2;
      const y = (canvas.height - height) / 2;
      ctx.drawImage(img, x, y, width, height);
      
      redrawAnnotations(ctx, x, y, width, height);
    }
  };

  const handleRecording = async () => {
    if (!isRecording) {
      try {
        const endpoint = recordingWithAudio ? '/recording/start-enhanced' : '/recording/start';
        const response = await fetch(`${API_BASE_URL}${endpoint}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            session_id: sessionId,
          }),
        });

        if (response.ok) {
          setIsRecording(true);
        } else {
          alert('Recording not available. Please check backend setup.');
        }
      } catch (error) {
        console.error('Error starting recording:', error);
        alert('Recording feature requires backend server to be running.');
      }
    } else {
      try {
        const response = await fetch(`${API_BASE_URL}/recording/stop`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            recording_id: sessionId,
          }),
        });

        if (response.ok) {
          const data = await response.json();
          setIsRecording(false);
          
          setProcessingVideo(true);
          await processVideoWithAI(data.video_path);
          setProcessingVideo(false);
        }
      } catch (error) {
        console.error('Error stopping recording:', error);
        setIsRecording(false);
      }
    }
  };

  const processVideoWithAI = async (videoPath) => {
    try {
      const response = await fetch(`${API_BASE_URL}/ai/enhanced-process-video`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          video_path: videoPath,
        }),
      });

      if (response.ok) {
        const data = await response.json();
        setOriginalTranscript(data.results.original_transcript || '');
        setAiProcessedTranscript(data.results.ai_processed_transcript || '');
        setAiResults(data.results);
        setActiveTab('ai');
      }
    } catch (error) {
      console.error('Error processing video:', error);
      // Mock AI results for demo
      const mockOriginal = "This is a simulated transcript of the screen recording session. The user reviewed the document and made several annotations highlighting key points.";
      const mockProcessed = "**AI ANALYSIS**: The session demonstrated effective document review with strategic highlighting of critical information. Key areas of focus included implementation timelines and budget considerations.";
      
      setOriginalTranscript(mockOriginal);
      setAiProcessedTranscript(mockProcessed);
      setAiResults({
        key_points: ['Demo analysis result 1', 'Demo analysis result 2'],
        processing_time: 2.5
      });
      setActiveTab('ai');
    }
  };

  const saveAsImage = async () => {
    if (!sessionId) return;

    try {
      const response = await fetch(`${API_BASE_URL}/save/image`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          session_id: sessionId,
          page_number: currentPage,
          annotations: annotations,
        }),
      });

      if (response.ok) {
        const data = await response.json();
        const link = document.createElement('a');
        link.href = `data:image/png;base64,${data.image_data}`;
        link.download = `document-page-${currentPage + 1}.png`;
        link.click();
      } else {
        const canvas = canvasRef.current;
        if (canvas) {
          const link = document.createElement('a');
          link.download = `document-page-${currentPage + 1}.png`;
          link.href = canvas.toDataURL();
          link.click();
        }
      }
    } catch (error) {
      console.error('Error saving image:', error);
      const canvas = canvasRef.current;
      if (canvas) {
        const link = document.createElement('a');
        link.download = `document-page-${currentPage + 1}.png`;
        link.href = canvas.toDataURL();
        link.click();
      }
    }
  };

  const downloadScreenshot = (screenshot) => {
    const link = document.createElement('a');
    link.href = `data:image/png;base64,${screenshot.image_base64}`;
    link.download = `annotation_${screenshot.id}.png`;
    link.click();
  };

  const openPreview = (screenshot) => {
    setCurrentPreview(screenshot);
    setShowPreviewModal(true);
  };

  const formatTime = (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  };

  const handleToolChange = (tool) => {
    setCurrentTool(tool);
  };

  const handleZoom = (direction) => {
    setZoom(prev => {
      const newZoom = direction === 'in' ? prev + 25 : prev - 25;
      return Math.max(25, Math.min(500, newZoom));
    });
  };

  const goToPage = (direction) => {
    const newPage = direction === 'next' ? currentPage + 1 : currentPage - 1;
    if (newPage >= 0 && newPage < totalPages) {
      loadPage(newPage);
    }
  };

  const ToolButton = ({ icon: Icon, isActive, onClick, tooltip, children }) => (
    <div className="relative group">
      <button
        onClick={onClick}
        className={`p-3 rounded-lg transition-all duration-200 transform hover:scale-105 ${
          isActive 
            ? 'bg-gradient-to-r from-blue-500 to-purple-600 text-white shadow-lg' 
            : 'bg-white/80 text-gray-700 hover:bg-white shadow-md border border-gray-200'
        }`}
      >
        {Icon ? <Icon size={20} /> : children}
      </button>
      <div className="absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-2 py-1 bg-gray-800 text-white text-xs rounded opacity-0 group-hover:opacity-100 transition-opacity whitespace-nowrap pointer-events-none z-50">
        {tooltip}
      </div>
    </div>
  );

  const ColorButton = ({ color, isActive, onClick }) => (
    <button
      onClick={() => onClick(color)}
      className={`w-8 h-8 rounded-full border-2 transition-all duration-200 transform hover:scale-110 ${
        isActive ? 'border-gray-800 scale-110 shadow-lg' : 'border-gray-300'
      }`}
      style={{ backgroundColor: color }}
    />
  );

  const TabButton = ({ id, label, icon: Icon, isActive, onClick, badge }) => (
    <button
      onClick={onClick}
      className={`flex items-center gap-2 px-4 py-2 rounded-lg font-medium transition-all duration-200 relative ${
        isActive 
          ? 'bg-blue-500 text-white shadow-lg' 
          : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
      }`}
    >
      <Icon size={18} />
      <span className="text-sm">{label}</span>
      {badge && (
        <span className="absolute -top-1 -right-1 bg-red-500 text-white text-xs rounded-full w-5 h-5 flex items-center justify-center">
          {badge}
        </span>
      )}
    </button>
  );

  // Render different tab content
  const renderTabContent = () => {
    switch (activeTab) {
      case 'tools':
        return (
          <>
            {/* Drawing Tools */}
            <div className="mb-8">
              <h3 className="text-lg font-semibold mb-4 text-gray-800">Drawing Tools</h3>
              <div className="grid grid-cols-2 gap-3 mb-4">
                <ToolButton
                  icon={Pen}
                  isActive={currentTool === 'pen'}
                  onClick={() => handleToolChange('pen')}
                  tooltip="Pen"
                />
                <ToolButton
                  icon={Highlighter}
                  isActive={currentTool === 'highlighter'}
                  onClick={() => handleToolChange('highlighter')}
                  tooltip="Highlighter"
                />
                <ToolButton
                  icon={Eraser}
                  isActive={currentTool === 'eraser'}
                  onClick={() => handleToolChange('eraser')}
                  tooltip="Eraser"
                />
                <ToolButton
                  icon={Trash2}
                  isActive={false}
                  onClick={clearAnnotations}
                  tooltip="Clear All"
                />
              </div>

              {/* Colors */}
              <div className="mb-4">
                <p className="text-sm font-medium text-gray-700 mb-2">Colors</p>
                <div className="flex flex-wrap gap-2">
                  {['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#000000', '#808080'].map(color => (
                    <ColorButton
                      key={color}
                      color={color}
                      isActive={penColor === color}
                      onClick={setPenColor}
                    />
                  ))}
                </div>
              </div>

              {/* Size */}
              <div className="mb-4">
                <p className="text-sm font-medium text-gray-700 mb-2">
                  Pen Size: {penSize}px
                </p>
                <input
                  type="range"
                  min="1"
                  max="20"
                  value={penSize}
                  onChange={(e) => setPenSize(parseInt(e.target.value))}
                  className="w-full accent-blue-500"
                />
              </div>
            </div>

            {/* Recording Controls */}
            <div className="mb-8">
              <h3 className="text-lg font-semibold mb-4 text-gray-800 flex items-center gap-2">
                <Brain size={20} className="text-purple-600" />
                Smart Recording
              </h3>
              
              {/* Audio Toggle */}
              <div className="mb-4">
                <label className="flex items-center gap-2 cursor-pointer">
                  <input
                    type="checkbox"
                    checked={recordingWithAudio}
                    onChange={(e) => setRecordingWithAudio(e.target.checked)}
                    className="w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500"
                  />
                  <span className="text-sm text-gray-700 flex items-center gap-1">
                    {recordingWithAudio ? <Mic size={16} className="text-green-600" /> : <MicOff size={16} className="text-red-600" />}
                    Record with audio
                  </span>
                </label>
              </div>
              
              <button
                onClick={handleRecording}
                className={`w-full p-4 rounded-lg font-medium transition-all duration-200 flex items-center justify-center gap-2 ${
                  isRecording 
                    ? 'bg-red-500 hover:bg-red-600 text-white animate-pulse' 
                    : 'bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 text-white shadow-lg transform hover:scale-105'
                }`}
              >
                {isRecording ? (
                  <>
                    <Square size={16} />
                    Stop Recording ({formatTime(recordingTime)})
                  </>
                ) : (
                  <>
                    <Play size={16} />
                    Start {recordingWithAudio ? 'Enhanced' : 'Basic'} Recording
                  </>
                )}
              </button>
              
              {processingVideo && (
                <div className="mt-3 p-3 bg-purple-50 rounded-lg border border-purple-200">
                  <div className="flex items-center gap-2 mb-2">
                    <Brain size={16} className="text-purple-600 animate-spin" />
                    <span className="text-sm font-medium text-purple-800">Processing with AI...</span>
                  </div>
                  <div className="w-full bg-purple-200 rounded-full h-2">
                    <div className="bg-purple-500 h-2 rounded-full animate-pulse w-2/3" />
                  </div>
                </div>
              )}
            </div>
          </>
        );

      case 'preview':
        return (
          <div className="mb-8">
            <h3 className="text-lg font-semibold mb-4 text-gray-800 flex items-center gap-2">
              <Camera size={20} className="text-blue-600" />
              Annotation Screenshots
            </h3>
            
            {screenshots.length === 0 ? (
              <div className="text-center py-8 text-gray-500">
                <Camera size={48} className="mx-auto mb-4 opacity-30" />
                <p>No screenshots yet</p>
                <p className="text-sm">Screenshots will appear here as you make annotations</p>
              </div>
            ) : (
              <div className="space-y-3 max-h-96 overflow-y-auto">
                {screenshots.map((screenshot) => (
                  <div key={screenshot.id} className="bg-gray-50 rounded-lg p-3 border">
                    <div className="flex items-start gap-3">
                      <img
                        src={`data:image/png;base64,${screenshot.image_base64}`}
                        alt="Annotation screenshot"
                        className="w-16 h-16 object-cover rounded cursor-pointer hover:opacity-80"
                        onClick={() => openPreview(screenshot)}
                      />
                      <div className="flex-1 min-w-0">
                        <div className="flex items-center gap-2 mb-1">
                          <span 
                            className="w-3 h-3 rounded-full" 
                            style={{ backgroundColor: screenshot.color }}
                          />
                          <span className="text-xs text-gray-500 capitalize">
                            {screenshot.annotation_type}
                          </span>
                        </div>
                        <p className="text-xs text-gray-600 mb-2">
                          {new Date(screenshot.timestamp).toLocaleTimeString()}
                        </p>
                        <div className="flex gap-1">
                          <button
                            onClick={() => openPreview(screenshot)}
                            className="text-xs bg-blue-500 text-white px-2 py-1 rounded hover:bg-blue-600"
                          >
                            View
                          </button>
                          <button
                            onClick={() => downloadScreenshot(screenshot)}
                            className="text-xs bg-green-500 text-white px-2 py-1 rounded hover:bg-green-600"
                          >
                            Save
                          </button>
                        </div>
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>
        );

      case 'ai':
        return (
          <div className="mb-8">
            <h3 className="text-lg font-semibold mb-4 text-gray-800 flex items-center gap-2">
              <MessageSquare size={20} className="text-green-600" />
              AI Transcript Analysis
            </h3>
            
            {!originalTranscript && !aiProcessedTranscript ? (
              <div className="text-center py-8 text-gray-500">
                <Brain size={48} className="mx-auto mb-4 opacity-30" />
                <p>No transcript available</p>
                <p className="text-sm">Record a session to see AI analysis</p>
              </div>
            ) : (
              <div className="space-y-4">
                {/* Original Transcript */}
                <div className="bg-blue-50 rounded-lg p-4 border border-blue-200">
                  <h4 className="font-semibold text-blue-800 mb-2 flex items-center gap-2">
                    <Mic size={16} />
                    Original Transcript
                  </h4>
                  <div className="max-h-32 overflow-y-auto">
                    <p className="text-sm text-blue-700 whitespace-pre-wrap">
                      {originalTranscript}
                    </p>
                  </div>
                  <div className="mt-2 text-xs text-blue-600">
                    {originalTranscript.split(' ').length} words
                  </div>
                </div>

                {/* AI Processed */}
                <div className="bg-green-50 rounded-lg p-4 border border-green-200">
                  <h4 className="font-semibold text-green-800 mb-2 flex items-center gap-2">
                    <Zap size={16} />
                    AI Analysis
                  </h4>
                  <div className="max-h-40 overflow-y-auto">
                    <div className="text-sm text-green-700 whitespace-pre-wrap">
                      {aiProcessedTranscript}
                    </div>
                  </div>
                  {aiResults && (
                    <div className="mt-3 pt-3 border-t border-green-200">
                      <div className="flex items-center justify-between text-xs text-green-600">
                        <span>Processing time: {aiResults.processing_time}s</span>
                        <span>Key insights extracted</span>
                      </div>
                    </div>
                  )}
                </div>
              </div>
            )}
          </div>
        );

      default:
        return null;
    }
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-indigo-50 via-white to-purple-50 flex">
      {/* Sidebar */}
      <div className={`bg-white/90 backdrop-blur-sm shadow-xl border-r border-gray-200 transition-all duration-300 ${
        showSidebar ? 'w-80' : 'w-0 overflow-hidden'
      }`}>
        <div className="p-6 h-full overflow-y-auto">
          <div className="mb-8">
            <h1 className="text-2xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent mb-2">
              AI PDF Editor
            </h1>
            <p className="text-sm text-gray-600">Smart annotation & analysis</p>
          </div>

          {/* File Upload */}
          <div className="mb-8">
            <h3 className="text-lg font-semibold mb-4 text-gray-800">Document</h3>
            <input
              type="file"
              ref={fileInputRef}
              onChange={handleFileUpload}
              accept=".pdf,.png,.jpg,.jpeg,.bmp,.gif"
              className="hidden"
            />
            <button
              onClick={() => fileInputRef.current?.click()}
              className="w-full p-4 border-2 border-dashed border-gray-300 rounded-lg text-center hover:border-blue-500 hover:bg-blue-50 transition-all duration-200 group"
            >
              <Upload size={24} className="mx-auto mb-2 text-gray-400 group-hover:text-blue-500" />
              <span className="text-gray-600 group-hover:text-blue-700">
                Click to upload PDF or image
              </span>
            </button>
            
            {fileName && (
              <div className="mt-3 p-3 bg-green-50 rounded-lg border border-green-200">
                <div className="flex items-center justify-between mb-2">
                  <span className="text-sm font-medium text-green-800 truncate">{fileName}</span>
                  <span className="text-xs text-green-600">{uploadProgress}%</span>
                </div>
                <div className="w-full bg-green-200 rounded-full h-2">
                  <div 
                    className="bg-green-500 h-2 rounded-full transition-all duration-300"
                    style={{ width: `${uploadProgress}%` }}
                  />
                </div>
              </div>
            )}
          </div>

          {/* Tabs */}
          {fileName && (
            <>
              <div className="mb-6">
                <div className="flex flex-wrap gap-2">
                  <TabButton
                    id="tools"
                    label="Tools"
                    icon={Settings}
                    isActive={activeTab === 'tools'}
                    onClick={() => setActiveTab('tools')}
                  />
                  <TabButton
                    id="preview"
                    label="Preview"
                    icon={Camera}
                    isActive={activeTab === 'preview'}
                    onClick={() => setActiveTab('preview')}
                    badge={screenshots.length || null}
                  />
                  <TabButton
                    id="ai"
                    label="AI Analysis"
                    icon={Brain}
                    isActive={activeTab === 'ai'}
                    onClick={() => setActiveTab('ai')}
                    badge={originalTranscript ? '1' : null}
                  />
                </div>
              </div>

              {/* Tab Content */}
              {renderTabContent()}

              {/* Page Navigation */}
              {totalPages > 0 && (
                <div className="mb-8">
                  <h3 className="text-lg font-semibold mb-4 text-gray-800">Pages</h3>
                  <div className="flex items-center justify-between mb-2">
                    <button 
                      onClick={() => goToPage('prev')}
                      disabled={currentPage === 0}
                      className="p-2 rounded-lg bg-gray-100 hover:bg-gray-200 transition-colors disabled:opacity-50"
                    >
                      <span className="text-sm">Prev</span>
                    </button>
                    <span className="text-sm font-medium">
                      {currentPage + 1} of {totalPages}
                    </span>
                    <button 
                      onClick={() => goToPage('next')}
                      disabled={currentPage === totalPages - 1}
                      className="p-2 rounded-lg bg-gray-100 hover:bg-gray-200 transition-colors disabled:opacity-50"
                    >
                      <span className="text-sm">Next</span>
                    </button>
                  </div>
                  
                  {/* Page thumbnails */}
                  <div className="grid grid-cols-2 gap-2 max-h-40 overflow-y-auto">
                    {Array.from({ length: totalPages }, (_, i) => (
                      <div
                        key={i}
                        className={`aspect-[3/4] rounded border-2 cursor-pointer transition-all duration-200 ${
                          i === currentPage 
                            ? 'border-blue-500 bg-blue-50' 
                            : 'border-gray-200 hover:border-gray-300 bg-gray-50'
                        }`}
                        onClick={() => loadPage(i)}
                      >
                        <div className="w-full h-full flex items-center justify-center">
                          <span className="text-xs text-gray-500">{i + 1}</span>
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              )}
            </>
          )}
        </div>
      </div>

      {/* Main Content */}
      <div className="flex-1 flex flex-col">
        {/* Top Toolbar */}
        <div className="bg-white/90 backdrop-blur-sm shadow-sm border-b border-gray-200 p-4">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-3">
              <button
                onClick={() => setShowSidebar(!showSidebar)}
                className="p-2 rounded-lg bg-gray-100 hover:bg-gray-200 transition-colors"
              >
                {showSidebar ? <EyeOff size={20} /> : <Eye size={20} />}
              </button>
              
              {fileName && (
                <div className="flex items-center gap-2">
                  <ToolButton
                    icon={Undo}
                    isActive={false}
                    onClick={undo}
                    tooltip="Undo"
                  />
                  <ToolButton
                    icon={Redo}
                    isActive={false}
                    onClick={redo}
                    tooltip="Redo"
                  />
                </div>
              )}
            </div>

            {fileName && (
              <div className="flex items-center gap-3">
                {/* Zoom Controls */}
                <div className="flex items-center gap-2 bg-gray-100 rounded-lg p-1">
                  <button
                    onClick={() => handleZoom('out')}
                    className="p-2 rounded hover:bg-gray-200 transition-colors"
                  >
                    <ZoomOut size={16} />
                  </button>
                  <span className="text-sm font-medium min-w-[60px] text-center">
                    {zoom}%
                  </span>
                  <button
                    onClick={() => handleZoom('in')}
                    className="p-2 rounded hover:bg-gray-200 transition-colors"
                  >
                    <ZoomIn size={16} />
                  </button>
                  <button
                    onClick={() => setZoom(100)}
                    className="p-2 rounded hover:bg-gray-200 transition-colors"
                  >
                    <RotateCcw size={16} />
                  </button>
                </div>

                {/* Save Options */}
                <div className="flex items-center gap-2">
                  <ToolButton
                    icon={Save}
                    isActive={false}
                    onClick={() => console.log('Save as PDF')}
                    tooltip="Save PDF"
                  />
                  <ToolButton
                    icon={Image}
                    isActive={false}
                    onClick={saveAsImage}
                    tooltip="Save Image"
                  />
                  <ToolButton
                    icon={Download}
                    isActive={false}
                    onClick={() => console.log('Download')}
                    tooltip="Download"
                  />
                </div>
              </div>
            )}
          </div>
        </div>

        {/* Canvas Area */}
        <div className="flex-1 flex items-center justify-center p-8 overflow-hidden">
          <div 
            className="bg-white rounded-lg shadow-2xl border border-gray-200 relative overflow-hidden"
            style={{
              width: `${800 * (zoom / 100)}px`,
              height: `${600 * (zoom / 100)}px`,
              maxWidth: '90%',
              maxHeight: '90%'
            }}
          >
            <canvas
              ref={canvasRef}
              className="w-full h-full cursor-crosshair"
              style={{ 
                cursor: currentTool === 'eraser' ? 'grab' : 'crosshair'
              }}
              onMouseDown={handleMouseDown}
              onMouseMove={handleMouseMove}
              onMouseUp={handleMouseUp}
              onMouseLeave={handleMouseUp}
            />
            
            {/* Loading overlay */}
            {uploadProgress > 0 && uploadProgress < 100 && (
              <div className="absolute inset-0 bg-black/50 flex items-center justify-center backdrop-blur-sm">
                <div className="bg-white rounded-lg p-6 text-center">
                  <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mx-auto mb-4" />
                  <p className="text-gray-700 font-medium">Loading document...</p>
                  <p className="text-sm text-gray-500">{uploadProgress}%</p>
                </div>
              </div>
            )}
            
            {/* Empty state */}
            {!fileName && (
              <div className="absolute inset-0 flex items-center justify-center text-center p-8">
                <div>
                  <FileText size={64} className="mx-auto mb-4 text-gray-300" />
                  <h3 className="text-xl font-semibold text-gray-600 mb-2">
                    Upload a document to get started
                  </h3>
                  <p className="text-gray-500 mb-4">
                    Drag and drop or click to select PDF or image files
                  </p>
                  <button
                    onClick={() => fileInputRef.current?.click()}
                    className="px-6 py-3 bg-gradient-to-r from-blue-500 to-purple-600 text-white rounded-lg font-medium hover:from-blue-600 hover:to-purple-700 transition-all duration-200 transform hover:scale-105 shadow-lg"
                  >
                    Choose File
                  </button>
                </div>
              </div>
            )}
          </div>
        </div>

        {/* Status Bar */}
        <div className="bg-white/90 backdrop-blur-sm border-t border-gray-200 p-3">
          <div className="flex items-center justify-between text-sm text-gray-600">
            <div className="flex items-center gap-4">
              <span>Tool: {currentTool}</span>
              <span>Color: {penColor}</span>
              <span>Size: {penSize}px</span>
              {screenshots.length > 0 && (
                <span className="text-blue-600">Screenshots: {screenshots.length}</span>
              )}
            </div>
            <div className="flex items-center gap-4">
              {isRecording && (
                <div className="flex items-center gap-2 text-red-600">
                  <div className="w-2 h-2 bg-red-500 rounded-full animate-pulse" />
                  <span>Recording: {formatTime(recordingTime)}</span>
                  {recordingWithAudio && <Mic size={16} />}
                </div>
              )}
              <span>Zoom: {zoom}%</span>
              {fileName && (
                <span className="truncate max-w-xs">
                  {fileName} (Page {currentPage + 1} of {totalPages})
                </span>
              )}
            </div>
          </div>
        </div>
      </div>

      {/* Preview Modal */}
      {showPreviewModal && currentPreview && (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50" onClick={() => setShowPreviewModal(false)}>
          <div className="bg-white rounded-lg p-6 max-w-2xl max-h-[80vh] overflow-auto" onClick={(e) => e.stopPropagation()}>
            <div className="flex items-center justify-between mb-4">
              <h3 className="text-lg font-semibold">Annotation Preview</h3>
              <button
                onClick={() => setShowPreviewModal(false)}
                className="p-2 hover:bg-gray-100 rounded-lg transition-colors"
              >
                Ã—
              </button>
            </div>
            
            <div className="mb-4">
              <img
                src={`data:image/png;base64,${currentPreview.image_base64}`}
                alt="Annotation preview"
                className="w-full rounded-lg border"
              />
            </div>
            
            <div className="space-y-2 text-sm text-gray-600">
              <div className="flex items-center gap-2">
                <span 
                  className="w-4 h-4 rounded-full" 
                  style={{ backgroundColor: currentPreview.color }}
                />
                <span className="capitalize">{currentPreview.annotation_type} annotation</span>
              </div>
              <div>Created: {new Date(currentPreview.timestamp).toLocaleString()}</div>
            </div>
            
            <div className="flex gap-2 mt-4">
              <button
                onClick={() => downloadScreenshot(currentPreview)}
                className="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors"
              >
                Download
              </button>
              <button
                onClick={() => setShowPreviewModal(false)}
                className="px-4 py-2 bg-gray-300 text-gray-700 rounded-lg hover:bg-gray-400 transition-colors"
              >
                Close
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default PDFEditor;